## Linear Search

linear search 의 과정을 보여주면서, array의 첫 번째 element부터 searching을 시작해 다음, 다음으로 계속 넘어가기 때문에 worst case의 경우에 O(N)의 시간복잡도를 가지게 된다는데 여기서 컴퓨터의 구조를 모르는 나는 궁금증이 생긴다.

항상 첫 번째 element부터 searching을 시작해야 한다는 건 그렇다 치자. 컴퓨터의 연산은 일관성이 있을 테니까. 그런데 array의 index를 하나씩 늘려가며 search한다는 과정 자체가 이해가 잘 안된다. 이게 뭐 사람이 눈으로 하나씩 옮겨가며 보는 것도 아니고.. 애초에 index가 하나씩 늘어나는 건 컴퓨터의 입장에선 뭘 의미하지? 진짜 모르겠다. data structure & algorithm 공부가 어느정도 무르익었을 때에는 반드시 computer architecture 공부를 병행해야 겠다.

<br><br>
***

## Check if N and Its Double Exist

Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).

More formally check if there exists two indices i and j such that :

>i != j
>
>0 <= i, j < arr.length
>
>arr[i] == 2 * arr[j]

>Example 1:
>
>>Input: arr = [10,2,5,3]
>>
>>Output: true
>
>Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.

My code:
```python
    class Solution(object):
    def checkIfExist(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        for i in range(len(arr)-1):
            for j in range(i+1, len(arr)):
                if float(arr[i]) == float(arr[j])/2 or arr[i] == 2*arr[j]:
                    return True
        return False
```

처음엔 float()로 감싸지 않고 arr[i] == arr[j]/2로 했는데 계속 test case 에서 (3,7)이 True로 나왔다. 처음에 type arr: List[int]로 돼있었기 때문으로, float로 감싸 해결했는데 뭔가 어영부영 해결한 느낌이 들어 찝찝하긴 했다. 아니나 다를까..

내 코드로 runtime이 매우 높게 나와 하위 9%정도의 성적을 거뒀다(...)
가장 runtime이 낮아 보이는 사람의 코드를 봤는데 대충 이런 식이었다.

```python    
    n = set()

    for num in arr:
        if num/2 in n:
            return True
        elif num * 2 in n:
            return True
        else:
            set.add(num)
    
    return False
```
캬.. 정말 깔끔하고 직관적인 코드다. 문제를 수학적으로 잘 설명한 코드인 것 같다. 나는 단순히 array 안에 n개의 element가 있으면 nC2의 조합이 생기므로 이중for문으로 돌려야겠다 생각을 했는데 애초에 '조합'이면 파이썬에서 친절하게 만들어 놓은 set을 이용할 생각을 했어야 했다.   


<br><br>
***

## Valid Mountain Array

Given an array of integers arr, return true if and only if it is a valid mountain array.

Recall that arr is a mountain array if and only if:

>arr.length >= 3
>
>There exists some i with 0 < i < arr.length - 1 such that:
>
>arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
>
>arr[i] > arr[i + 1] > ... > arr[arr.length - 1]

수학적으로 말하자면 (엄격한)증가->(엄격한)감수 함수꼴이어야 한다는 것이다.

>Constraints:
>
>>1 <= arr.length <= 10^4
>>
>>0 <= arr[i] <= 10^4

My code:
```python

    class Solution(object):
    def validMountainArray(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        n = 0
        
        if len(arr) < 3:
            return False
        else:
            while n < len(arr)-2 and arr[n] < arr[n+1]:
                n += 1
            if arr[n] == arr[n+1]:
                return False
            elif n > 0:
                while n < len(arr)-1 and arr[n] > arr[n+1]:
                    n += 1
                if n == len(arr)-1:
                    return True
                else:
                    return False
            else:
                return False
```

증가 -> 감소 하는 경우만이 True를 받을 수 있는 logic flow를 생각하면서 코드를 작성하긴 했는데, 생각보다 깔끔하게 나오진 않았다. 그래도 상위 40%라서 나름 잘했...다고 생각하고 있었는데 가장 잘한 코드를 보니 또 충격을 받았다.

array의 index를 따라가며 조건을 만족하는지 추적하는 i를 설정하고, 중간중간 만족하지 않았을 때 return False를 넣어주고,
마지막에 **return i == len(arr)** 를 설정한 게 정말 충격이었다... 그 한줄로 내 많은 줄을 대신할 수 있었다.

<br><br>
***

## Replace Elements with Greatest Element on Right Side

Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.

After doing so, return the array.

>Example 1:
>
>>Input: arr = [17,18,5,4,6,1]
>>
>>Output: [18,6,6,6,1,-1]
>
>Explanation: 
>>- index 0 --> the greatest element to the right of index 0 is index 1 (18).
>>- index 1 --> the greatest element to the right of index 1 is index 4 (6).
>>- index 2 --> the greatest element to the right of index 2 is index 4 (6).
>>- index 3 --> the greatest element to the right of index 3 is index 4 (6).
>>- index 4 --> the greatest element to the right of index 4 is index 5 (1).
>>- index 5 --> there are no elements to the right of index 5, so we put -1.

My code:
```python

    class Solution(object):
    def replaceElements(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        l = len(arr)
        
        temp_after = 0 # this is for storing later element
        temp_before = 0 # this is for storing element which will be writed later
        
        if l > 1:
            for i in range(1, l):
                temp_before = arr[l-i]
                arr[l-i] = temp_after
                if arr[l-i] >= temp_before:
                    temp_after = arr[l-i]
                else:
                    temp_after = temp_before
            arr[0] = temp_after
        
        arr[l-1] = -1 
        
        return arr
```

휴.. 이번 문제는 좀 잘한듯..다행히도 - 아 근데 temp_after랑 temp_before이랑 주석이 바뀌었다...흑

edge case도 잘 고려했고, 쓸데없는 줄도 없다. temp를 적절히 이용해 메모리 사용을 줄였고, for문으로 코드의 반복을 줄였다.

